<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>web</title>
    <link href="/2026/01/21/web/"/>
    <url>/2026/01/21/web/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="进攻与防御"><a href="#进攻与防御" class="headerlink" title="进攻与防御"></a>进攻与防御</h2><p>进攻性安全专注于一件事：入侵系统。入侵系统可能通过利用漏洞、滥用不安全的设置以及利用未强制的访问控制策略等方式实现。红队和渗透测试人员专门从事进攻性安全。<br>防御性安全（蓝队）与进攻性安全相反，它涉及两项主要任务：<br>1.防止入侵发生<br>2.在入侵发生时检测并做出适当响应<br>与防御性安全相关的一些任务包括：</p><ul><li>用户网络安全意识：对用户进行网络安全培训有助于防范针对其系统的各种攻击。</li><li>记录和管理资产：我们需要了解必须妥善管理和保护的系统和设备的类型。</li><li>更新和修补系统：确保计算机、服务器和网络设备正确更新并修补任何已知漏洞（弱点）。</li><li>设置预防性安全设备：防火墙和入侵防御系统 ( IPS) 是预防性安全的重要组成部分。防火墙控制哪些网络流量可以进入以及哪些可以离开系统或网络。IPS会阻止任何符合现有规则和攻击特征的网络流量。</li><li>设置日志记录和监控设备：如果没有适当的网络日志记录和监控，就无法检测到恶意活动和入侵。如果我们的网络上出现了新的未经授权的设备，我们应该能够知道。<br>安全运营中心( SOC )<br>是由网络安全专业人员组成的团队，负责监控网络及其系统以检测恶意网络安全事件。SOC的主要关注领域包括：</li><li>漏洞：每当发现系统漏洞（弱点）时，必须通过安装适当的更新或补丁来修复它。当无法修复时，应采取必要措施防止攻击者利用它。虽然修复漏洞对于 SOC 至关重要，但不一定分配给他们。</li><li>违反政策</li><li>检测未经授权的活动</li><li>网络入侵</li></ul><h2 id="数字取证和事件响应-DFIR"><a href="#数字取证和事件响应-DFIR" class="headerlink" title="数字取证和事件响应 ( DFIR )"></a>数字取证和事件响应 ( DFIR )</h2><p>1.数字取证（分析攻击及其实施者的证据以及其他领域，例如知识产权盗窃、网络间谍活动和持有未经授权的内容）<br>2.事件响应（事件通常是指数据泄露或网络攻击；但在某些情况下，事件也可能是不太严重的事件，例如配置错误、入侵企图或违反政策）<br>3.恶意软件分析<br>数字取证包括：</p><ul><li>文件系统：分析系统存储的数字取证图像（低级副本）可以揭示许多信息，例如已安装的程序、创建的文件、部分覆盖的文件和已删除的文件。</li><li>系统内存：如果攻击者在内存中运行恶意程序而不将其保存到磁盘，则获取系统内存的取证映像（低级副本）是分析其内容和了解攻击的最佳方法。</li><li>系统日志：每台客户端和服务器计算机都维护着不同的日志文件，记录正在发生的事情。日志文件提供了大量有关系统上发生的事情的信息。即使攻击者试图清除他们的痕迹，也会留下一些痕迹。</li><li>网络日志：穿过网络的网络数据包的日志将有助于回答有关是否发生攻击以及攻击会带来什么后果的更多问题。<br>事件响应四个主要阶段是：</li><li>准备：这需要一支训练有素、随时准备处理事故的团队。理想情况下，应采取各种措施，防止事故发生。</li><li>检测和分析：团队拥有检测任何事件所需的资源；此外，进一步分析任何检测到的事件以了解其严重程度至关重要。</li><li>遏制、根除和恢复：一旦检测到事件，至关重要的是阻止其影响其他系统、消除它并恢复受影响的系统。例如，当我们注意到某个系统感染了计算机病毒时，我们希望阻止（遏制）病毒传播到其他系统、清除（根除）病毒并确保系统正常恢复。</li><li>事件后活动：成功恢复后，生成报告并分享经验教训，以防止将来发生类似事件。<br>恶意软件分析<br>Malware 代表恶意软件。软件是指可以保存在磁盘上或通过网络发送的程序、文档和文件。恶意软件包括多种类型，例如：</li><li>病毒是附着在程序上的一段代码（程序的一部分）。病毒的设计目的是从一台计算机传播到另一台计算机；此外，一旦感染计算机，病毒就会改变、覆盖和删除文件。病毒的后果包括计算机运行缓慢甚至无法使用。</li><li>特洛伊木马是一种程序，它表面上显示一个可取的功能，但实际上却隐藏着恶意功能。例如，受害者可能会从可疑网站下载视频播放器，从而使攻击者完全控制其系统。</li><li>勒索软件是一种加密用户文件的恶意程序。加密会使文件在不知道加密密码的情况下无法读取。如果用户愿意支付“赎金”，攻击者就会向用户提供加密密码。</li></ul><h2 id="网络前置知识"><a href="#网络前置知识" class="headerlink" title="网络前置知识"></a>网络前置知识</h2><p>设备有两种识别方式，其中一种是可渗透的。</p><ul><li>IP 地址（可改变）</li><li>媒体访问控制 (MAC) 地址 - 可以将其视为类似于序列号（不可变）<br>IP 地址（或Internet协议）<br>可在一段时间内用作识别网络上主机的一种方式，然后该 IP 地址可与另一台设备关联，而无需更改 IP 地址。<br>IP地址是一组分为四个八位字节的数字。每个八位字节的值将汇总为网络上设备的 IP 地址，IP 地址可以在不同设备之间更改，但不能在同一网络中同时处于活动状态多次<br>MAC地址<br>网络上的所有设备都具有物理网络接口，即设备主板上的微芯片板。此网络接口在出厂时被分配了一个唯一的地址，称为 MAC （媒体访问控制）地址。MAC 地址是一个十二个字符的十六进制数（一种用于计算的十六进制数字系统），分成两部分并用冒号分隔。这些冒号被视为分隔符。例如，a4:c3:f0:85:ac:2d。前六个字符代表制造网络接口的公司，后六个字符是一个唯一的数字。MAC地址可以被伪造（欺骗）</li></ul><p>Ping 是我们可以使用的最基本的网络工具之一。Ping 使用ICMP（Internet控制消息协议）数据包来确定设备之间连接的性能</p><p>渗透测试阶段：<br>1.信息收集 2.枚举&#x2F;扫描 3.开发 4.权限提升 5.后期开发<br>OSSTMM(开放源软件)主要包括：电信（电话、VoIP），有线网络，无线通信<br>OWASP(开放web服务)：测试web应用程序和服务的安全性<br>NIST 网络安全框架1.1：用于提高组织的网络安全标准和管理网络威胁风险<br>NCSC CAF:包含十四项原则的广泛框架，用于评估各种网络威胁的风险以及组织对这些威胁的防御措施。</p><p>黑盒测试：是一个高级过程，其中测试人员不会获得有关应用程序或服务内部运作的任何信息。（没有被授权访问源代码的测试过程）<br>灰盒测试：测试人员对应用程序或软件的内部组件有一定的了解，但仍会像在黑盒场景中一样与应用程序进行交互，然后利用他们对应用程序的了解尝试解决发现的问题<br>白盒测试：低级过程，通常由了解编程和应用程序逻辑的软件开发人员完成。测试人员将测试应用程序或软件的内部组件，例如，确保特定功能在合理的时间内正常运行。（可以访问源代码）</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="日志分类与理解"><a href="#日志分类与理解" class="headerlink" title="日志分类与理解"></a>日志分类与理解</h2><p>1.日志的分类与理解</p><ul><li>系统日志：包括操作系统生成的日志，比如登录记录、系统调用、权限更改等。通常位于&#x2F;var&#x2F;log目录（Linux）或事件查看器（Windows）中。</li><li>应用日志：应用程序生成的日志，例如Web服务器日志（如Nginx、Apache）、数据库日志等。</li><li>网络日志：如防火墙日志、IDS&#x2F;IPS（入侵检测&#x2F;防御系统）日志、网络流量日志，记录外部连接和通信行为。</li></ul><p>2.重要日志文件位置示例：</p><ul><li>Linux系统：</li><li>&#x2F;var&#x2F;log&#x2F;auth.log：记录用户认证相关信息。</li><li>&#x2F;var&#x2F;log&#x2F;syslog：系统级别的重要事件。</li><li>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log和&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log：Nginx的访问和错误日志。</li><li>Windows系统：</li><li>安全日志：记录用户登录、权限变更等安全事件。</li><li>系统日志：记录系统事件，如设备驱动故障或系统崩溃。</li></ul><h2 id="识别常见攻击行为"><a href="#识别常见攻击行为" class="headerlink" title="识别常见攻击行为"></a>识别常见攻击行为</h2><p>1.暴力破解攻击：</p><ul><li>通过分析登录失败的频率和来源IP，识别是否存在暴力破解的尝试。可以重点关注连续的、频繁的登录失败。</li><li>在Linux中，查看&#x2F;var&#x2F;log&#x2F;auth.log或&#x2F;var&#x2F;log&#x2F;secure，寻找诸如“Failed password”的条目。<br>2.SQL注入攻击：</li><li>Web服务器日志中，观察HTTP请求中是否存在常见的SQL注入模式，例如带有’ OR 1&#x3D;1 –、UNION SELECT等关键词的查询参数。</li><li>查看access.log日志，特别是带有异常字符（如’, –, &#x3D;等）的URL请求。<br>3.XSS（跨站脚本攻击）：</li><li>检查请求中是否包含常见的XSS攻击特征，比如<code>&lt;script&gt;</code>标签或<code>onerror=alert()</code>等JavaScript代码。Web服务器的<code>access.log</code>是重点检查对象。<br>4.扫描和探测行为：</li><li>网络日志中，查看是否有来自同一IP的大量端口扫描行为（连续的多端口访问，特别是空连接）。</li><li>使用工具如tcpdump、Wireshark来捕获流量，查看是否有异常的端口或IP通信。<br>5.后门和恶意软件活动：</li><li>检查系统日志中是否有异常的系统服务启动、计划任务的执行，或有进程意外启动。</li><li>分析网络日志，查看是否有系统向未知或可疑的外部地址发出请求，可能是恶意软件在进行数据外泄。</li></ul><h2 id="快速分析日志的工具和方法"><a href="#快速分析日志的工具和方法" class="headerlink" title="快速分析日志的工具和方法"></a>快速分析日志的工具和方法</h2><ul><li>grep（Linux）<br>快速搜索日志中包含特定关键字的条目。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;Failed password&quot;</span> /var/log/auth.log<br></code></pre></td></tr></table></figure>例如，通过grep过滤特定关键词（如“Failed password”）查看登录失败的情况。</li><li>awk<br>用于提取日志中的特定字段，进一步分析。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&#x27;&#123;print $1, $4, $5&#125;&#x27;</span> /var/log/auth.log | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr<br></code></pre></td></tr></table></figure>可以分析来源IP及其频率，确定是否存在异常行为。</li><li>tail -f<br>：实时查看日志变化，适用于快速监控。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -f /var/log/nginx/access.log<br></code></pre></td></tr></table></figure></li><li>Splunk&#x2F;ELK（ElasticSearch, Logstash, Kibana）<br>：高级日志分析工具，可以收集、索引和可视化日志数据，帮助你更高效地分析海量日志。</li><li>Fail2ban<br>：自动监控日志文件，根据预定义的规则检测异常行为（如多次失败的登录尝试），并自动采取防护措施（如封锁IP地址）。</li></ul><h2 id="检测模式和异常特征"><a href="#检测模式和异常特征" class="headerlink" title="检测模式和异常特征"></a>检测模式和异常特征</h2><p>1.频繁失败的登录尝试：短时间内多次登录失败的日志，可能是暴力破解的迹象。<br>2.非正常工作时间的活动：用户在非正常工作时间（如凌晨）进行登录或执行敏感操作，可能是异常行为。<br>3.流量峰值和异常通信：网络日志中突然出现的大量请求或异常通信，可能预示着扫描、DDoS攻击或数据泄露。</p><h2 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h2><p>1.IP封禁<br>  检测到异常行为后，可以通过防火墙或工具（如Fail2ban）自动封禁攻击来源IP地址。</p><ul><li>Linux下使用iptables：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -A INPUT -s [攻击者IP] -j DROP<br></code></pre></td></tr></table></figure></li><li>Windows下使用防火墙规则：<ul><li>打开Windows防火墙，并添加规则禁止特定IP地址访问。<br>2.加固登录机制</li><li>限制登录失败次数：配置如&#x2F;etc&#x2F;security&#x2F;faillock.conf，限制连续登录失败的次数。</li><li>启用双因素认证（2FA）：即使密码泄露，也能防止未经授权的登录。<br>3.更新和修补系统<br>确保及时应用系统和软件的安全补丁，修复已知漏洞，降低被攻击的风险。<br>4.关闭不必要的服务<br>减少暴露面，确保系统中只运行必要的服务和端口，防止攻击者利用不必要的开放端口或服务进行攻击。<br>5.日志监控自动化<br>可以设置定期的日志分析和告警系统（如通过ELK、Splunk或Fail2ban），自动检测异常行为并发送告警通知，让你能及时采取防护措施。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流量分析</title>
    <link href="/2026/01/14/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <url>/2026/01/14/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><h2 id="Wireshark过滤语法"><a href="#Wireshark过滤语法" class="headerlink" title="Wireshark过滤语法"></a>Wireshark过滤语法</h2><ul><li><p>IP过滤：<br>ip.addr eq 192.168.1.107<br>来源：ip.src eq 192.168.1.107<br>目标： ip.dst eq 192.168.1.107</p></li><li><p>端口过滤<br>tcp.port eq 80<br>tcp.port &#x3D;&#x3D; 80<br>目标端口80：tcp.dstport &#x3D;&#x3D; 80<br>来源端口80：tcp.srcport &#x3D;&#x3D; 80<br>过滤端口范围：tcp.port &gt;&#x3D; 1 and tcp.port &lt;&#x3D; 80</p></li><li><p>协议过滤<br>tcp、udp、arp、icmp、http、smtp、ftp、dns、msnms、ip、oicq、bootp等</p></li><li><p>MAC过滤<br>eth.addr eq A0:00:00:04:C5:84<br>目标mac：eth.dst &#x3D;&#x3D; A0:00:00:04:C5:84<br>来源mac：eth.src eq A0:00:00:04:C5:84 </p></li><li><p>长度过滤<br>udp.length &#x3D;&#x3D; 26（udp固定长度8+udp下面那块数据包之和）<br>tcp.len &gt;&#x3D; 7 （ip数据包即tcp下面那块数据,不包括tcp本身）<br>ip.len &#x3D;&#x3D; 94 （除以太网头固定长度14,其它都算是ip.len,即从ip本身到最后）<br>frame.len &#x3D;&#x3D; 119 （整个数据包长度,从eth开始到最后）</p></li><li><p>http模式过滤</p><img src="image1.png" width="600"></li><li><p>TCP参数过滤:<br>1.TCP（传输控制协议）</p></li><li><p>作用：提供可靠的、面向连接的通信，确保数据包按顺序传输且不丢失。</p></li><li><p>应用：HTTP、FTP、SMTP等基于TCP的应用协议。</p></li><li><p>过滤应用：可以过滤特定端口的TCP流量，如80端口（HTTP）、443端口（HTTPS）。<br>2.UDP（用户数据报协议）</p></li><li><p>作用：提供无连接的、不可靠的数据传输，适用于需要快速传输的小数据包的应用。</p></li><li><p>应用：DNS查询、视频流、在线游戏等。</p></li><li><p>过滤应用：可以根据应用过滤场景特定端口的UDP流量，如53端口（DNS）。</p></li></ul><ol start="3"><li>ARP（地址解析协议）</li></ol><ul><li>作用：将IP地址解析为物理MAC地址，用于同等局域网内的通信。</li><li>过滤应用：可用于检测和阻止ARP欺骗攻击。</li></ul><ol start="4"><li>ICMP（互联网控制消息协议）</li></ol><ul><li>作用：用于网络设备之间发送错误消息和操作信息，如ping命令。</li><li>过滤应用：可以过滤ping请求和响应，以防止ICMP洪水攻击。</li></ul><ol start="5"><li>HTTP（超文本传输​​协议）</li></ol><ul><li>作用：用于在Web浏览器和服务器之间传输超文本，主要用于网页访问。</li><li>过滤应用：可以过滤HTTP流量以控制网页访问或监控网络使用情况。</li></ul><ol start="6"><li>SMTP（简单邮件传输协议）</li></ol><ul><li>作用：用于电子邮件的发送和转发。</li><li>过滤应用：可过滤SMTP流量以防止垃圾邮件或监控邮件通信。<br>7.FTP（文件传输协议）</li><li>作用：用于在客户端和服务器之间传输文件。</li><li>过滤应用：可限制或监控FTP流量以确保安全的文件传输。</li></ul><ol start="8"><li>DNS（域名系统）</li></ol><ul><li>作用：将域名解析为IP地址。</li><li>过滤应用：可以过滤DNS查询，防止以DNS欺骗攻击或拦截恶意网站。</li></ul><ol start="9"><li>MSNMS（微软网络信使服务）</li></ol><ul><li>作用：用于即时消息传递（如旧版的Windows Messenger）。</li><li>过滤应用：可以阻止即时消息应用程序的使用。</li></ul><ol start="10"><li>IP（互联网协议）</li></ol><ul><li>作用：提供网络设备之间的基本数据传输功能。</li><li>过滤应用：可以根据源或目标IP地址进行过滤，控制哪些设备可以通信。<br>11.OICQ（开放式ICQ）</li><li>作用：基于ICQ协议的即时通讯软件，类似于早期的QQ。</li><li>过滤应用：可以过滤此类即时通讯流量以控制员工使用情况。</li></ul><ol start="12"><li>BOOTP（引导协议）</li></ol><ul><li>作用：用于从服务器获取IP地址等信息，类似于DHCP。</li><li>过滤应用：可用于控制和监控网络中的动态IP地址分配。</li></ul><h1 id="jwt认证"><a href="#jwt认证" class="headerlink" title="jwt认证"></a>jwt认证</h1><p>[jwtTOKEN在线解码] <a href="https://tooltt.com/jwt-decode/">https://tooltt.com/jwt-decode/</a></p><h2 id="传统session认证："><a href="#传统session认证：" class="headerlink" title="传统session认证："></a>传统session认证：</h2><p>http无状态协议，基于cookie保存信息并在下一次发送的方式，是传统的session认证<br>缺点：用户过多时服务器开销大、限制了应用扩展力、cookie被截获时的安全问题</p><h2 id="基于token的鉴权机制："><a href="#基于token的鉴权机制：" class="headerlink" title="基于token的鉴权机制："></a>基于token的鉴权机制：</h2><p>类似于http无状态，不在服务端保存信息<br>流程：</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据<br>token必须要在每次请求时传递给服务端，应保存在请求头里。且服务端要支持CORS策略<br>JWT由三段信息组成：头部（header）、载荷（payload）、签证（signature）。三部分由“.”分隔连接<br>形如：xxxxxxx.yyyyyyyy.zzzzzz<br>header由两部分构成：token类型声明和加密算法名称<br>如： {<br>   ‘typ’: ‘JWT’,<br>   ‘alg’: ‘HS256’<br>}<br>然后将头部进行base64加密，便得到jwt第一部分</li></ul><p>payload包含声明（要求）<br>声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p><ul><li><p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。<br>比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p></li><li><p>Public claims : 可以随意定义。</p></li><li><p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子：<br>如：{</p><pre><code class="hljs">  &quot;sub&quot;: &#39;1234567890&#39;,        &quot;name&quot;: &#39;john&#39;,  &quot;admin&quot;:true</code></pre><p>}</p></li></ul><p>对payload进行Base64编码就得到JWT的第二部分</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>MISC</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MISC_工具集</title>
    <link href="/2025/12/05/TOOLS/"/>
    <url>/2025/12/05/TOOLS/</url>
    
    <content type="html"><![CDATA[<h1 id="隐写类工具"><a href="#隐写类工具" class="headerlink" title="隐写类工具"></a>隐写类工具</h1><h2 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h2><p>1.010editor</p><ul><li>查看16进制</li><li>搜索关键字，查找文本、16进制</li><li>修改文件数据（补齐文件头、修改伪加密、修改宽高）</li><li>文件对比</li><li>词频分析</li></ul><p>2.honview<br>可支持多种格式看图，如bpg，gif<br>图片批量转换成bpg 可以用honeyview 的资源管理器右键菜单</p><p>3.pngdebugger<br>查看png数据，检查各数据块CRC是否正确</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pngdebugger  地址<br></code></pre></td></tr></table></figure><p>查看IHDR详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pngdebugger --verbose 地址<br></code></pre></td></tr></table></figure><p>保存信息（生成的文本保存在debug目录下）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pngdebugger  地址 &gt; 1.txt<br></code></pre></td></tr></table></figure><p>4.stegsolve</p><ul><li>面板功能：<br>  File Format:文件格式<br>  Data Extract:数据提取<br>  Steregram Solve:立体试图 可以左右控制偏移<br>  Frame Browser:帧浏览器<br>  Image Combiner:拼图</li><li>常用操作<br>  反色查看<br>  数据提取<br>  左右偏移<br>  动图分离帧</li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>MISC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BurpSuit使用</title>
    <link href="/2025/12/01/BurpSuit_usage/"/>
    <url>/2025/12/01/BurpSuit_usage/</url>
    
    <content type="html"><![CDATA[<h2 id="前置基础知识"><a href="#前置基础知识" class="headerlink" title="前置基础知识"></a>前置基础知识</h2><h3 id="主页面模块"><a href="#主页面模块" class="headerlink" title="主页面模块"></a>主页面模块</h3><p>1.Dashboard(扫描与审计)<br>2.Target(目标)——显示目标目录结构的的一个功能<br>3.Proxy(代理)——拦截HTTP&#x2F;S的代理服务器，作为在浏览器和目标应用程序之间的中间人，允许拦截、查看和修改在两个方向上的原始数据流。<br>4.Spider(爬虫)——自动爬取网站目录和内容。<br>5.Scanner(扫描器)——自动扫描web漏洞。<br>6.Intruder(入侵)——高度可配置的工具，可用作自动化攻击，如爆破密码、枚举目录、SQL 注入等。<br>7.Repeater(重放器)——手动操作修改重发某个单个请求。<br>8.Comparer（对比器）——对比两个请i去&#x2F;响应的差异<br>9.Sequencer(会话)——用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具。<br>10.Decoder(解码器)——进行手动执行或对应用程序数据者智能解码编码的工具。<br>11.Comparer(对比)——通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”。<br>12.Logger(日志记录器)——记录和审计所有经过 Burp Proxy 的 HTTP&#x2F;HTTPS 流量<br>13.Extender(扩展)——安装插件扩展功能。</p><h3 id="功能及具体使用"><a href="#功能及具体使用" class="headerlink" title="功能及具体使用"></a>功能及具体使用</h3><p>1.Proxy<br><img src="image1.png" width="600"><br>proxy-intercept可以审计当前的请求，或者存储和发送到其他的页面进行其他的操作等<br><img src="image2.png" width="600"><br>在其他地方导入其他的请求数据包<br>拦截当前数据包的 返回包，可以进行伪造验证等操作<br>对当前输入时候的对象进行urlcode编码，一些特殊的符号会自动转换成url编码<br><img src="image3.png" width="600"></p><p>proxy—-http hitsory模块 记录请求日志功能<br>proxy—-options模块 监听配置</p><p>2.Intruder<br>将请求包发送到intruder<br><img src="image4.png" width="600"></p><ul><li>Positions：设置请求中的参数及攻击类型</li><li>Payloads：为上面的参数设置数据集、参数编码、加密等功能</li><li>Resource Pool：指定请求线程及延时时间<img src="image5.png" width="600"></li><li>Sniper 使用一组数据集合，依次对 $ 标记的变量进行爆破，即：针对一个参数变量，使用一个数据集合<br>[使用场景：单一目标，已知用户名，密码未知]</li><li>Battering ram 使用一组数据集合，同时对 $ 标记的所有变量进行爆破，即：针对多个参数变量，使用一个数据集合<br>[使用场景：两个单一目标，相互不影响]</li><li>Pitchfork 使用多组数据集合，同时爆破被 $ 标记的变量，即：针对多个参数变量，使用多个数据集合<br>[使用场景：用户名和密码都未知，每个用户名只使用一个密码进行攻击]</li><li>Cluster bomb 使用多组数据集合进行组合（笛卡尔积）后，依次对多个爆破点变量进行爆破，即：针对多个变量，使用多个数据集合的组合<br>[使用场景：两个目标，每个用户名使用所有密码都进行一次攻击]<img src="image6.png" width="600">在 Positions 标签下，我们需要先点击右侧的「 Clear § 」按钮来清除默认的参数标签然后鼠标选择需要设置为变量的值，点击右侧的「 Add § 」按钮来设置它为变量<img src="image7.png" width="600">导入字典，”start attact“进行暴破<img src="image8.png" width="600">正确的密码长度和其他稍有不同</li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>基础知识笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编码</title>
    <link href="/2025/12/01/code/"/>
    <url>/2025/12/01/code/</url>
    
    <content type="html"><![CDATA[<h2 id="Morse编码"><a href="#Morse编码" class="headerlink" title="Morse编码"></a>Morse编码</h2><p>一种早期的数字化通信形式<br><img src="image1.png" width="600"></p><h2 id="敲击码"><a href="#敲击码" class="headerlink" title="敲击码"></a>敲击码</h2><p>敲击码是基于 5 ×5 方格波利比奥斯方阵来实现的，通过使用一系列的点击声音来编码而命名，c与k整合在一起<br>（相似对比）棋盘密码：将26个字母放在5×5的方格里，i,j放在一个格子里<br><img src="image2.png" width="600"></p><h2 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h2><p>通过电平的高低转换来表示“0”或“1”，每一位的中间有一个跳变的动作<br><img src="image3.png" width="600"></p><h2 id="格雷码GrayCode"><a href="#格雷码GrayCode" class="headerlink" title="格雷码GrayCode"></a>格雷码GrayCode</h2><p>格雷码是一个数列集合，每个数使用二进制位来表示<br>用n位元来表示每个数</p><ul><li>位元即每组数列基础数的个数，n位元就是n个二进制数<br>任意两个相邻的代码只有一位二进制数不同，最大数与最小数之间也仅一位数不同，即“首尾相连”</li><li>eg：3位元格雷码 000 001 011 010 110 111</li><li>eg：4位元格雷码 0000 0001 0011 0010 0110 0111 0101 0100</li></ul><h2 id="ascii编码"><a href="#ascii编码" class="headerlink" title="ascii编码"></a>ascii编码</h2><img src="image4.png" width="600"><h2 id="base家族"><a href="#base家族" class="headerlink" title="base家族"></a>base家族</h2><p>二进制编码规则<br>原始数据三字节为一组，每组24个二进制位<br>24个二进制位每6位一组，分为四组<br>每组前补00，构成每组8位<br>将四组8位的二进制转换成四组十进制<br>再根据base规则编码转换对应字符<br>其实base16就是hex</p><ul><li>Base16：0-9、A-F构成，不会出现”&#x3D;”</li><li>Base32：由A-Z、2-7构成，“&#x3D;”作后缀填充</li><li>Base58：不使用数字”0”，大写”O”，”I”(小写是i)，和”l”(大写是L)，以及”+“和”&#x2F;“。<br>（是用于比特币中使用的一种独特的编码方式，主要用于产生比特币的钱包地址）   </li><li>Base62：由A-Z、a-z、0-9构成。<br>(相比于base64,只是去掉了两个符号（+和&#x2F;）)    </li><li>Base64：由A-Z、a-z、0-9、+、&#x2F; 构成，“&#x3D;”作后缀填充<br>非二进制→二进制→每6bit计算十进制→base64对照表，</li><li>Base91：由91个字符（0-9，a-z，A-Z,!#$%&amp;()*+,.&#x2F;:;&lt;&#x3D;&gt;?@[]^_&#96;{|}~”）组成</li></ul><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>移位密码，通过key在字母表中的顺序移位实现</p><h2 id="Rot13"><a href="#Rot13" class="headerlink" title="Rot13"></a>Rot13</h2><p>凯撒密码的13位，即密钥key为13</p><h2 id="url密码-（-编码）"><a href="#url密码-（-编码）" class="headerlink" title="url密码 （%编码）"></a>url密码 （%编码）</h2><p>原理：先转换成ascii，再将ascii转换为16进制，最后在每一位前加上‘%’<br>tips：在网址导航栏中有url</p><h2 id="培根bacon密码"><a href="#培根bacon密码" class="headerlink" title="培根bacon密码"></a>培根bacon密码</h2><p>利用’A’,’B’加密</p><h2 id="栅栏fence密码"><a href="#栅栏fence密码" class="headerlink" title="栅栏fence密码"></a>栅栏fence密码</h2><p>把明文分成N个组，然后取出每组的第一个，每组的第二个……接着按顺序排列得出密文</p><h2 id="jother编码（JSFuck）"><a href="#jother编码（JSFuck）" class="headerlink" title="jother编码（JSFuck）"></a>jother编码（JSFuck）</h2><p>在javascript语言中，利用少量特定字符构造精简的匿名函数对与字符串的编码方式.代码中大量出现“+”、“！”、“（”、“）”、“[”、“]”、“{”、“}”字符<br>例如:!![]+!![]+!![]+!![]+!![]+!![]</p><h2 id="unicode编码"><a href="#unicode编码" class="headerlink" title="unicode编码"></a>unicode编码</h2><p>每位前为’\u’，</p><h2 id="埃特巴什码-Atbash-Cipher"><a href="#埃特巴什码-Atbash-Cipher" class="headerlink" title="埃特巴什码(Atbash Cipher)"></a>埃特巴什码(Atbash Cipher)</h2><p>（Dr.熊斐特）<br>最后一个字母代表第一个字母，倒数第二个字母代表第二个字母</p><h2 id="Html编码"><a href="#Html编码" class="headerlink" title="Html编码"></a>Html编码</h2><p><a href="http://www.w3school.com.cn/charsets/ref_html_entities_v.asp">http://www.w3school.com.cn/charsets/ref_html_entities_v.asp</a><br>UTF-8<br>每位以‘&amp;#’开始，以‘；’结束</p><h2 id="UUencode"><a href="#UUencode" class="headerlink" title="UUencode"></a>UUencode</h2><p>二进制到文字的编码，最早在unix 邮件系统中使用，全称：Unix-to-Unix </p><h2 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h2><p>每三个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32<br>产生的结果刚好落在ASCII字符集（32-空白…95-底线）的范围之中</p><h2 id="XXencode"><a href="#XXencode" class="headerlink" title="XXencode"></a>XXencode</h2><p>将输入文本以每三个字节为单位进行编码。如剩下的少于三个字节，不够的用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz，共64个字符。<br>跟base64字符相比，UUencode多一个“-” 字符，少一个”&#x2F;” 字符</p><h2 id="一些奇奇怪怪的密码"><a href="#一些奇奇怪怪的密码" class="headerlink" title="一些奇奇怪怪的密码"></a>一些奇奇怪怪的密码</h2><p>1.Ook密码<br>2.社会主义核心价值观密码<br>3.当铺密码：<br>当前汉字有多少笔画出头，就是转化成数字几<br>4.盲文<br>5.猪圈密码<br><img src="image5.png" width="600"><br>圣骑士团密码（猪圈变种）<br><img src="image6.png" width="600"><br>6.文本加密<br><a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php">https://www.qqxiuzi.cn/bianma/wenbenjiami.php</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>MISC</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐写基础_文件结构</title>
    <link href="/2025/12/01/%E9%9A%90%E5%86%99%E5%9F%BA%E7%A1%80_%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2025/12/01/%E9%9A%90%E5%86%99%E5%9F%BA%E7%A1%80_%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="隐写基础知识-文件结构"><a href="#隐写基础知识-文件结构" class="headerlink" title="隐写基础知识_文件结构"></a>隐写基础知识_文件结构</h1><img src="文件结构.png" width="600"><h2 id="常见文件类型"><a href="#常见文件类型" class="headerlink" title="常见文件类型"></a>常见文件类型</h2><h3 id="png"><a href="#png" class="headerlink" title="png"></a>png</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">文件头：89 50 4E 47 0D 0A 1A 0A<br>文件尾：49 45 4E 44 AE 42 60 82<br></code></pre></td></tr></table></figure><p>构成：文件头 + 三个以上png数据块<br>数据块：<br>1.关键数据块（标准数据块）—— 4 个标准数据块，PNG必需的数据块<br> 包括：文件头数据块（IHDR）， 调色板数据块（PLTE）<br>             图像数据块（IDAT），图像结束数据块（IEND）<br>IHEAD：包括了图片的宽，高，图像深度，颜色类型，压缩方法等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">PLTE（palette chunk调色板数据块）：包含与索引彩色图像（indexed-color image）相关的彩色变换数据，它仅与索引彩色图像有关，且要放在图像数据块（image data chunk）之前。真彩色的 PNG 数据流也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像。<br>IDAT（image data chunk图像数据块）：存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。IDAT 块只有当上一个块充满时，才会继续一个新的块<br></code></pre></td></tr></table></figure><p>IDAT隐写基础<br> IEND（image trailer chunk图像结束数据）：标记 PNG 文件或者数据流结束，必须放在文件尾部</p><p>2.辅助数据块（可选数据块）<br>包括：tRNS、bKGD、gAMA、sBIT等。</p><h3 id="JPG"><a href="#JPG" class="headerlink" title="JPG"></a>JPG</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">文件头：FF D8<br>文件尾：FF D9<br></code></pre></td></tr></table></figure><p>JPEG 是有损压缩格式，将像素信息用 JPEG 保存成文件再读取出来，其中某些像素值会有少许变化。保存时质量参数可在 0 至 100 之间选择，参数越大图片就越保真，但体积也越大。一般情况下选择 70 或 80<br><img src="JPG.png" width="600"></p><h3 id="APNG"><a href="#APNG" class="headerlink" title="APNG"></a>APNG</h3><p>APNG（Animated Portable Network Graphics，Animated PNG）是基于 PNG 格式扩展的一种位图动画格式，增加了对动画图像的支持，同时加入了 24 位真彩色图像和 8 位 Alpha 透明度的支持，动画拥有更好的质量。</p><ul><li><p>相比 gif 可以容纳更多的色彩;且向下兼容 png 格式图片</p></li><li><p>支持 alpha 透明通道</p></li><li><p>图片体积相比 gif 更小<br>除 APNG 外，常见的动画格式还有 GIF 和 WebP，区别如下</p><img src="APNG1.png" width="600">APNG 在 PNG 的基础上增加了 acTL、fcTL 和 fdAT 3 种块<img src="APNG2.png" width="600"></li><li><p>acTL：动画控制块，包含了图片的帧数和循环次数（ 0 表示无限循环）</p></li><li><p>fcTL：帧控制块，属于 PNG 规范中的辅助块，包含了当前帧的序列号、图像的宽高及水平垂直偏移量，帧播放时长和绘制方式（dispose_op 和 blend_op）等，每一帧只有一个 fcTL 块</p></li><li><p>fdAT：帧数据块，包含了帧的序列号和图像数据，仅比 IDAT 多了帧的序列号，每一帧可以有一个或多个 fcTL 块。fdAT 的序列号与 fcTL 共享，用于检测 APNG 的序列错误，可选择性的纠正<br>IDAT 块是 APNG 向下兼容展示时的默认图片。如果 IDAT 之前有 fcTL， 那么 IDAT 的数据则当做第一帧图片（如上图结构），如果 IDAT 之前没有 fcTL，则第一帧图片是第一个 fdAT</p></li></ul><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">文件头：47 49 46 38 39 61<br>文件尾：3b<br></code></pre></td></tr></table></figure><ul><li>文件头（File Header）</li><li>GIF 文件署名（Signature）：即‘GIF’三个符号，确认GIF格式</li><li>版本号（Version）：三个字节组成，87a或89a</li><li>GIF 数据流（GIF Data Stream）</li><li>控制标识符</li><li>图象块（Image Block）</li><li>其他的一些扩展块</li><li>文件终结器（Trailer）：固定值 0x3b</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GIF常考分离帧，在每一帧图片中隐藏信息<br></code></pre></td></tr></table></figure><h3 id="BMP"><a href="#BMP" class="headerlink" title="BMP"></a>BMP</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">文件头：42 4D C0 01<br></code></pre></td></tr></table></figure><p>Bitmap（位图）或是DIB（设备无关位图），Windows系统中广泛使用的图像文件格式</p><ul><li>文件头(bmp file header)：文件格式、大小等信息</li><li>位图信息头(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息</li><li>调色板(color palette)：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表</li><li>位图数据(bitmap data)：图像数据</li></ul><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p>Linux中，ELF文件全称为：Executable and Linkable Format，主要有三种形式，分别是：</p><ul><li>可执行文件</li><li>动态库文件（共享文件 .so）</li><li>目标文件（可重定位文件 .o）</li></ul><h3 id="DOCX"><a href="#DOCX" class="headerlink" title="DOCX"></a>DOCX</h3><p>DOCX 文 件 头 为 “50 4B 03 04”，与 ZIP 文件头类似，  这是由于 DOCX 文档的结构是按照压缩原理设计的<br>DOCX 文档的目录结构展开来看和压缩文件一样具有文件系统的文件组织 形式，并以树状结构排列，包含目录和子目录，其 中叶子节点是一些文件流<br>一般 DOCX 文档包含 [Content_Types].xml 文件、rels 文件夹、docProps类文件和文档内容类文件（一般在 word、custom 等文件夹下）<br>1.1[Content_Types].xml 文件对整个文档中内容所对应的媒体类型进行说明<br>应用程序读取 DOCX 文件时，先解析 [Content_ Types].xml，就可以在 [Content_Types].xml 中得到文 档所用到的格式、内容、图片等所对应的媒体类型 以及保存的位置，为下一步调用指出入口<br>对于大部分 DOCX 文档来说，[Content_ Types].xml 的内容都是类似的，也就是说文档格式  的媒体类型一样，生成的文件夹和子文件夹以及文件名称相同，只是在项目数量上有区别<br>1.2rels 是 relationships 的缩写，  用来定义文档格式 与媒体类型之间的对应关系<br>根据 rels 可以快速得到各部件和媒体类型格式包的 对应关系，不需要考虑具体的格式，可以节省读取时间<br>根 _rels 文件夹和 word、custom 等文件夹下都存 储有 rels 类文件，根文件夹下的 rels 文件解释文档中主部件和顶级包的关系<br>word 文件夹下的 rels 文件 document.xml.rels 列 出 document.xml 所需的其他部件，如果文档中有用户自定义的一些属性，则会在 custom 文件夹下分别 创建以 item 命名的 rels 文件，进一步解释当前文件 夹下子部件和包的对应关系<br>1.3docProps 文件夹中包括core.xml、app.xml、custom.xml 等<br>1.4文档解析内容<br>word、custom 等文件夹保存了用户对文档的各种操作。custom 中 以 item 为首命名的 xml 文件解释文档中的自定义数据部件，这个部件对 文档的整 体内容影响不大，即使缺失也可以正常读取文档内容。word 文件夹中包含了大量 xml 文件，用来解 释文档的页眉、页脚、批注、脚注、尾注、web 设 置、自定义设置、格式、内容等<br>2.1基于关联对象的信息隐藏<br>[Content_Types].xml 作 为 DOCX 文 档 的 入 口，文档中每添加一类对象， 就需要在 [Content_Types]. xml 进行声明</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>MISC</category>
      
      <category>基础知识_隐写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MISC</tag>
      
      <tag>基础知识笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐写</title>
    <link href="/2025/12/01/%E9%9A%90%E5%86%99/"/>
    <url>/2025/12/01/%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="文本隐写"><a href="#文本隐写" class="headerlink" title="文本隐写"></a>文本隐写</h1><h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">crypto的内容有些多，因此有关内容我在“编码”中单独写了一篇，记录常见的编码方式<br></code></pre></td></tr></table></figure><a href="/2025/12/01/code/" title="编码">常见编码方式</a><h2 id="可见字符隐写"><a href="#可见字符隐写" class="headerlink" title="可见字符隐写"></a>可见字符隐写</h2><p>信息隐藏在可见字符，如空格数量、大小写、标点、特定位置等。<br>常见方式有：</p><ul><li>用空格数量代表0或1</li><li>首字母拼接</li><li>大小写代表0或1</li></ul><h2 id="不可见字符隐写"><a href="#不可见字符隐写" class="headerlink" title="不可见字符隐写"></a>不可见字符隐写</h2><h3 id="零宽隐写"><a href="#零宽隐写" class="headerlink" title="零宽隐写"></a>零宽隐写</h3><p>零宽度字符是一些不可见的，不可打印的字符。存在于页面中主要用于调整字符的显示格式<br>一般的文本编辑器中不可见，将文本储存为txt格式，用vim查看可以直接看到其中隐藏的零宽度字符<br>U+200B零宽度空格符 (zero-width space)  : 用于较长单词的换行分隔<br> U+FEFF零宽度非断空格符 (zero-width no-break space) : 用于阻止特定位置的换行分隔<br> U+200D零宽度连字符 (zero-width joiner) : 用于阿拉伯文与印度语系等文字中，使不会发生连字的字符间产生连字效果<br>U+200C 零宽度断字符 (zero-width non-joiner) : 用于阿拉伯文，德文，印度语系等文字中，阻止会发生连字的字符间的连字效果<br>U+200E左至右符 (left-to-right mark)  : 用于在混合文字方向的多种语言文本中（例：混合左至右书写的英语与右至左书写的希伯来语），规定排版文字书写方向为左至右<br> U+200F右至左符 (right-to-left mark) : 用于在混合文字方向的多种语言文本中，规定排版文字书写方向为右至左<br><a href="https://offdev.net/demos/zwsp-steg-js">https://offdev.net/demos/zwsp-steg-js</a><br>参考：<br>[转化为二进制的加密]<a href="https://zhuanlan.zhihu.com/p/87919817">https://zhuanlan.zhihu.com/p/87919817</a><br>[转化为Morse编码的加密]<a href="https://zhuanlan.zhihu.com/p/75992161">https://zhuanlan.zhihu.com/p/75992161</a></p><h3 id="SNOW"><a href="#SNOW" class="headerlink" title="SNOW"></a>SNOW</h3><p>SNOW 用于通过在行尾附加空格和制表符来隐藏 ASCII 文本中的消息，即文本隐写</p><h2 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h2><p>1.伪加密<br>一个zip文件由三部分组成：<br>压缩源文件数据区、压缩源文件目录区、压缩源文件目录结束标志<br><img src="image1.png" width="600"><br>zip 压缩源文件目录区的全局方式位标记改为奇数 01 00 或者 09 00，就是伪加密</p><p>2.破解</p><ul><li>字典暴破&#x2F;掩码攻击&#x2F;已知明文攻击<br>工具：ziperello，ARCHPR</li><li>CRC32碰撞<br>CRC32算法通过对输入数据的每个字节运算，生成一个32位的校验和。CRC暴破是基于已知的校验和尝试找出原始输入数据，通过遍历可能的输入数据，可以找到匹配的原始值</li></ul><h1 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h1><h2 id="文件头隐写"><a href="#文件头隐写" class="headerlink" title="文件头隐写"></a>文件头隐写</h2><p>根据16进制查看文件类型，一般是修改了文件格式或要补全文件头</p><h2 id="IDAT块隐写"><a href="#IDAT块隐写" class="headerlink" title="IDAT块隐写"></a>IDAT块隐写</h2><p>pngdebugger可以检查crc、tweakpng可以对idat块进行操作<br>工具：pngdebugger、tweakpng<br>关于什么时候该删除什么idat块？<br>1.使用tweakpng将图片的idat块合并<br>2.在kali中使用binwalk检查idat块内的偏移值（合并前、合并后的差值）<br>3.再回到tweak根据偏移值分离IDAT块，删除多余部分，再保存即可</p><h2 id="宽高修改"><a href="#宽高修改" class="headerlink" title="宽高修改"></a>宽高修改</h2><p>高度被修改的遮住了部分信息，图片其余部分还可以正常显示<br>宽度被修改则无法正常显示<br>一般被修改过宽高的图片在kali中不能正常打开，但在windows中可以打开<br>png：width为宽，height为高<br><img src="img1.png" width="600"><br>jpg：Y,X<br><img src="img2.png" width="600"><br>bmp：LONG biWidth,biHeight<br><img src="img3.png" width="600"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#同时爆破宽度和高度</span><br>import zlib<br>import struct<br>filename = <span class="hljs-string">&quot;misc.png&quot;</span><br>with open(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) as f:<br>all_b = f.read()<br>data = bytearray(all_b[12:29])<br>n = 4095<br><span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(n):<br>width = bytearray(struct.pack(<span class="hljs-string">&#x27;&gt;i&#x27;</span>, w))<br><span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> range(n):<br>height = bytearray(struct.pack(<span class="hljs-string">&#x27;&gt;i&#x27;</span>, h))<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(4):<br>data[x+4] = width[x]<br>data[x+8] = height[x]<br>crc32result = zlib.crc32(data)<br><span class="hljs-comment">#替换成图片的crc 在010中为第二行后三个，和第三行第一个</span><br><span class="hljs-keyword">if</span> crc32result == 0x76EC1E40:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;宽为：&quot;</span>, end = <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>(width, end = <span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>(int.from_bytes(width, byteorder=<span class="hljs-string">&#x27;big&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;高为：&quot;</span>, end = <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>(height, end = <span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>(int.from_bytes(height, byteorder=<span class="hljs-string">&#x27;big&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="文件分离"><a href="#文件分离" class="headerlink" title="文件分离"></a>文件分离</h2><p>有时候会把几个文件合并成一个文件，例如在一张图片中隐藏一个压缩包，flag很有可能藏在压缩包中，这时候需要分离文件将压缩包拿出来。<br>在kali中：<br>binwalk命令可以检测是否有其他文件存在<br>foremost命令可以直接分离图片</p><h2 id="LSB-最低有效位"><a href="#LSB-最低有效位" class="headerlink" title="LSB 最低有效位"></a>LSB 最低有效位</h2><p>工具：stegsolve<br>仅可对png、bmp无损图片格式使用<br>LSB 隐写就是修改 RGB 颜色分量的最低二进制位（LSB），每个颜色会有 8 bit，LSB 隐写就是修改了像数中的最低的 1 bit，每个像素可以携带 3 比特的信息</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>MISC</category>
      
      <category>基础知识_隐写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MISC</tag>
      
      <tag>基础知识笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/08/hello-world/"/>
    <url>/2024/04/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
